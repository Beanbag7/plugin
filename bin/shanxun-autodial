#!/bin/sh
# shanxun-autodial: PPPoE 自动拨号 + 短信取密 + 自动更新密码
# 依赖：ubus, jsonfilter, sms-tool(/sms_tool), uci, logger

UCI_BIN="${UCI_BIN:-/sbin/uci}"
JSONFILTER_BIN="${JSONFILTER_BIN:-/usr/bin/jsonfilter}"
UBUS_BIN="${UBUS_BIN:-/bin/ubus}"
LOG_FALLBACK="/var/log/shanxun.log"
STATE_FILE="/var/run/shanxun.state"
CFG_NS="shanxun"
CFG_SEC="shanxun.config"

cfg_get() { $UCI_BIN -q get $CFG_SEC.$1 2>/dev/null; }

log() {
  local msg="$*"
  local LOG_FILE="$(cfg_get log_file || echo "$LOG_FALLBACK")"
  mkdir -p "$(dirname "$LOG_FILE")" 2>/dev/null
  echo "$(date '+%F %T') $msg" >> "$LOG_FILE"
  logger -t shanxun "$msg"
}

load_cfg() {
  ENABLED="$(cfg_get enabled || echo 1)"
  IFACE="$(cfg_get iface || echo wan)"
  SMS_DEV="$(cfg_get sms_device || echo /dev/ttyUSB2)"
  SMS_BAUD="$(cfg_get sms_baud || echo 115200)"
  SMS_NUM="$(cfg_get sms_number || echo 10000)"
  SMS_TEXT="$(cfg_get sms_text || echo MM)"
  SMS_SENDER_FILTER="$(cfg_get sms_sender_filter || echo '')"
  PASS_RE="$(cfg_get password_regex || echo '[0-9]{4,32}')"
  EXPIRY_RE="$(cfg_get expiry_regex || echo '[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}')"
  CHECK_INTERVAL="$(cfg_get check_interval || echo 30)"
  DIAL_TIMEOUT="$(cfg_get dial_timeout || echo 20)"
  RETRIES="$(cfg_get retries || echo 2)"
  SMS_WAIT="$(cfg_get sms_wait || echo 60)"
  LOG_FILE="$(cfg_get log_file || echo "$LOG_FALLBACK")"
  SMS_SEND_CMD="$(cfg_get sms_send_cmd || echo '')"
  SMS_RECV_CMD="$(cfg_get sms_recv_cmd || echo '')"
  SC_KEY="$(cfg_get sc_key || echo '')"
}

# 掩码显示（用于日志，不改变实际值）
mask() { 
  local s="$1"
  [ -z "$s" ] && echo "-" && return
  local len=${#s}
  if [ $len -le 4 ]; then
    echo "****"
  else
    local pre="${s:0:2}"
    local suf="${s: -2}"
    echo "${pre}***${suf}"
  fi
}

mask_key() {
  local k="$1"
  [ -z "$k" ] && echo "" && return
  local len=${#k}
  if [ $len -le 8 ]; then
    printf '%.0s*' $(seq 1 $len)
  else
    local prefix="${k:0:4}"
    local suffix="${k: -4}"
    echo "${prefix}***${suffix}"
  fi
}

push_notification() {
  local title="$1"
  local msg="$2"

  [ -z "$SC_KEY" ] && return 1

  if ! command -v curl >/dev/null 2>&1; then
    log "ServerChan 推送失败：未安装 curl"
    return 1
  fi

  log "正在推送通知到 ServerChan (key=$(mask_key "$SC_KEY"))..."
  curl -s -X POST "https://sctapi.ftqq.com/${SC_KEY}.send" \
    --data-urlencode "title=${title}" \
    --data-urlencode "desp=${msg}" \
    -o /dev/null
  local rc=$?
  if [ $rc -eq 0 ]; then
    log "ServerChan 推送成功"
    return 0
  else
    log "ServerChan 推送失败 (curl 退出码: $rc)"
    return 1
  fi
}

# 安全执行用户自定义命令模板（占位符替换），返回命令退出码
safe_exec_cmd() {
  local tpl="$1"; shift
  local cmd="$tpl"
  for kv in "$@"; do
    local k="${kv%%=*}"
    local v="${kv#*=}"
    cmd="${cmd//\\{$k\}/'$v'}"
  done
  log "执行自定义命令：${cmd}"
  sh -c "$cmd"
  return $?
}

send_sms() {
  local num="$1"
  local txt="$2"

  if [ -n "$SMS_SEND_CMD" ]; then
    safe_exec_cmd "$SMS_SEND_CMD" dev="$SMS_DEV" baud="$SMS_BAUD" num="$num" msg="$txt" >/dev/null 2>&1
    local rc=$?
    if [ $rc -eq 0 ]; then
      return 0
    else
      log "自定义发送命令执行失败 (rc=$rc)：$SMS_SEND_CMD"
    fi
  fi

  if command -v sms-tool >/dev/null 2>&1; then
    log "发送短信: sms-tool -d $SMS_DEV -b $SMS_BAUD send $num \"$txt\""
    sms-tool -d "$SMS_DEV" -b "$SMS_BAUD" send "$num" "$txt" >/dev/null 2>&1 && return 0
  fi
  if command -v sms_tool >/dev/null 2>&1; then
    log "发送短信: sms_tool -d $SMS_DEV -b $SMS_BAUD -t $num -s \"$txt\""
    sms_tool -d "$SMS_DEV" -b "$SMS_BAUD" -t "$num" -s "$txt" >/dev/null 2>&1 && return 0
  fi

  log "发送短信失败：未找到可用工具或命令执行失败"
  return 1
}

read_last_sms() {
  if [ -n "$SMS_RECV_CMD" ]; then
    log "正在读取短信（自定义命令）：$SMS_RECV_CMD"
    sh -c "$SMS_RECV_CMD" 2>/dev/null | sed -n '1,1p'
    return ${PIPESTATUS[0]:-0}
  fi

  if command -v sms-tool >/dev/null 2>&1; then
    log "正在读取短信：使用 sms-tool"
    sms-tool -d "$SMS_DEV" -b "$SMS_BAUD" read --newest 2>/dev/null | sed -n '1,1p'
    return ${PIPESTATUS[0]:-0}
  fi
  if command -v sms_tool >/dev/null 2>&1; then
    log "正在读取短信：使用 sms_tool"
    sms_tool -d "$SMS_DEV" -b "$SMS_BAUD" read --newest 2>/dev/null | sed -n '1,1p'
    return ${PIPESTATUS[0]:-0}
  fi

  log "读取短信失败：未找到可用工具"
  return 1
}

parse_password_and_expiry() {
  local text
  text="$(cat 2>/dev/null || echo '')"
  local pass=""
  local exp=""

  log "收到短信原文（摘要）: $(printf '%s' "$text" | head -c 200 | sed 's/"/\\"/g')"

  if [ -n "$PASS_RE" ]; then
    pass="$(printf '%s' "$text" | grep -oE "$PASS_RE" | sed -n '1p')"
  fi
  if [ -z "$pass" ]; then
    pass="$(printf '%s' "$text" | grep -oE '[0-9]{4,32}' | head -n1)"
  fi

  if [ -n "$EXPIRY_RE" ]; then
    exp="$(printf '%s' "$text" | grep -oE "$EXPIRY_RE" | sed -n '1p')"
  fi
  if [ -z "$exp" ]; then
    exp="$(printf '%s' "$text" | grep -oE '[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}' | head -n1)"
  fi

  pass="$(printf '%s' "$pass" | tr -d '\r\n"')"
  exp="$(printf '%s' "$exp" | tr -d '\r\n"')"

  log "解析到密码(部分显示)=$(mask "$pass") 有效期=${exp:--}"
  printf 'PASS=%s\nEXPIRY=%s\n' "$pass" "$exp"
  return 0
}

# ... rest of original script remains unchanged ...
